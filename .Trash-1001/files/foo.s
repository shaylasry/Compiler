;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 48

section .data
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_BOOL(0)
MAKE_BOOL(1)
MAKE_LITERAL_STRING "whatever"
MAKE_LITERAL_SYMBOL(const_tbl + 6)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_RATIONAL(-1,1)
MAKE_LITERAL_RATIONAL(5,1)
MAKE_LITERAL_RATIONAL(3,1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+8*0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+8*1], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+8*2], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+8*3], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+8*4], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+8*5], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+8*6], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+8*7], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+8*8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+8*9], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+8*10], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+8*11], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+8*12], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+8*13], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+8*14], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+8*15], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+8*16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+8*17], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+8*18], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+8*19], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+8*20], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+8*21], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+8*22], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+8*23], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+8*24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+8*25], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+8*26], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+8*27], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+8*28], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+8*29], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+8*30], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+8*31], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 224]
push rax
mov rax, qword [fvar_tbl + 232]
push rax
mov rax, qword [fvar_tbl + 216]
push rax
mov rax, qword [fvar_tbl + 208]
push rax
mov rax, qword [fvar_tbl + 32]
push rax

            push 5  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 41; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode1)
 pop r8
         
 jmp Lcont1
 Lcode1:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode3)
 pop r8
         
 jmp Lcont3
 Lcode3:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 40]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 40], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode5)
 pop r8
         
 jmp Lcont5
 Lcode5:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_6
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_6:
            ;                     finish generate applic
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_7
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_7:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse0
mov rax, const_tbl +1; insert const from const table to rax
 jmp Lexit3
Lelse0:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
        
 mov rax, qword [rax]
        
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_16
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_16:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_17
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_17:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
        
 mov rax, qword [rax]
        
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_12
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_12:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_13
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_13:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_9
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop2:
              cmp rcx, rsp            ;end of new stack
              jl Change2
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop2
Change2:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_9:
        ;                           finish generate applic tp
Lexit3:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont5:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode7)
 pop r8
         
 jmp Lcont7
 Lcode7:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_20
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_20:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse1
mov rax, const_tbl +1; insert const from const table to rax
 jmp Lexit18
Lelse1:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_29
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_29:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
        
 mov rax, qword [rax]
        
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_30
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_30:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_25
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_25:
            ;                     finish generate applic
push rax

            push 1  ; number of args
mov rax, qword [rbp + 32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_26
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_26:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_22
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop4:
              cmp rcx, rsp            ;end of new stack
              jl Change4
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop4
Change4:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_22:
        ;                           finish generate applic tp
Lexit18:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont7:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 40]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS

 ; generate lambda opt
          
 MALLOC rax, 24
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode9)
 pop r8
         
 jmp Lcont9
 Lcode9:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 1, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 1)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_33
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop6:
              cmp rcx, rsp            ;end of new stack
              jl Change6
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop6
Change6:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_33:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont9:

 leave
             
 ret
         
 Lcont3:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_2
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop0:
              cmp rcx, rsp            ;end of new stack
              jl Change0
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop0
Change0:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_2:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont1:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_34
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_34:
            ;                     finish generate applic
mov [fvar_tbl+32*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 32]
push rax
mov rax, qword [fvar_tbl + 216]
push rax
mov rax, qword [fvar_tbl + 208]
push rax

            push 3  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode10)
 pop r8
         
 jmp Lcont11
 Lcode10:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode12)
 pop r8
         
 jmp Lcont13
 Lcode12:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode14)
 pop r8
         
 jmp Lcont15
 Lcode14:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 48]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_40
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_40:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse2
mov rax, qword [rbp + 40]
 jmp Lexit38
Lelse2:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 48]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_48
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_48:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 48]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_45
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_45:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 40]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_46
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_46:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_42
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop10:
              cmp rcx, rsp            ;end of new stack
              jl Change10
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop10
Change10:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_42:
        ;                           finish generate applic tp
Lexit38:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont15:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode16)
 pop r8
         
 jmp Lcont17
 Lcode16:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 48]
push rax
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_50
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop12:
              cmp rcx, rsp            ;end of new stack
              jl Change12
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop12
Change12:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_50:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont17:
         ;                    finish generate lambda simple

 leave
             
 ret
         
 Lcont13:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_37
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop8:
              cmp rcx, rsp            ;end of new stack
              jl Change8
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop8
Change8:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_37:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont11:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_51
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_51:
            ;                     finish generate applic
mov [fvar_tbl+33*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 32]
push rax
mov rax, qword [fvar_tbl + 216]
push rax
mov rax, qword [fvar_tbl + 208]
push rax

            push 3  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode18)
 pop r8
         
 jmp Lcont19
 Lcode18:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode20)
 pop r8
         
 jmp Lcont21
 Lcode20:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode22)
 pop r8
         
 jmp Lcont23
 Lcode22:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 48]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_57
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_57:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse3
mov rax, qword [rbp + 40]
 jmp Lexit55
Lelse3:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 48]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_64
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_64:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 3  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_65
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_65:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 48]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_61
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_61:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 32]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_59
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop16:
              cmp rcx, rsp            ;end of new stack
              jl Change16
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop16
Change16:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_59:
        ;                           finish generate applic tp
Lexit55:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont23:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode24)
 pop r8
         
 jmp Lcont25
 Lcode24:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 48]
push rax
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_67
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop18:
              cmp rcx, rsp            ;end of new stack
              jl Change18
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop18
Change18:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_67:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont25:
         ;                    finish generate lambda simple

 leave
             
 ret
         
 Lcont21:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_54
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop14:
              cmp rcx, rsp            ;end of new stack
              jl Change14
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop14
Change14:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_54:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont19:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_68
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_68:
            ;                     finish generate applic
mov [fvar_tbl+34*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 232]
push rax
mov rax, qword [fvar_tbl + 272]
push rax
mov rax, qword [fvar_tbl + 32]
push rax

            push 3  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode26)
 pop r8
         
 jmp Lcont27
 Lcode26:
 push rbp
             
 mov rbp, rsp
             
 
 ; generate lambda opt
          
 MALLOC rax, 16
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode28)
 pop r8
         
 jmp Lcont29
 Lcode28:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 0, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 0)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 32]
push rax
mov rax, const_tbl +1; insert const from const table to rax
push rax
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode29)
 pop r8
         
 jmp Lcont31
 Lcode29:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_75
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_75:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse4
mov rax, qword [rbp + 32]
 jmp Lexit73
Lelse4:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 32]
push rax
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_77
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop22:
              cmp rcx, rsp            ;end of new stack
              jl Change22
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop22
Change22:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_77:
        ;                           finish generate applic tp
Lexit73:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont31:
         ;                    finish generate lambda simple
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_72
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop20:
              cmp rcx, rsp            ;end of new stack
              jl Change20
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop20
Change20:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_72:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont29:
 leave
             
 ret
         
 Lcont27:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_78
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_78:
            ;                     finish generate applic
mov [fvar_tbl+35*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define

 ; generate lambda opt
          
 MALLOC rax, 8
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode31)
 pop r8
         
 jmp Lcont33
 Lcode31:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 0, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 0)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 mov rax, qword [rbp + 32]
 leave
             
 ret
         
 Lcont33:
mov [fvar_tbl+36*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 216]
push rax
mov rax, qword [fvar_tbl + 24]
push rax
mov rax, qword [fvar_tbl + 32]
push rax

            push 3  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode32)
 pop r8
         
 jmp Lcont35
 Lcode32:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode34)
 pop r8
         
 jmp Lcont37
 Lcode34:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode36)
 pop r8
         
 jmp Lcont39
 Lcode36:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_85
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_85:
            ;                     finish generate applic
cmp rax, SOB_FALSE_ADDRESS
                                                                
 jne Lexit84
;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_88
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_88:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse5
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_92
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_92:
            ;                     finish generate applic
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_90
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop26:
              cmp rcx, rsp            ;end of new stack
              jl Change26
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop26
Change26:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_90:
        ;                           finish generate applic tp
 jmp Lexit86
Lelse5:
mov rax, const_tbl +2; insert const from const table to rax
Lexit86:
             ;                  finish generate if

Lexit84:
 leave
             
 ret
         
 Lcont39:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 32]
        
 mov rax, qword [rax]
        

 leave
             
 ret
         
 Lcont37:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_82
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop24:
              cmp rcx, rsp            ;end of new stack
              jl Change24
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop24
Change24:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_82:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont35:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_93
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_93:
            ;                     finish generate applic
mov [fvar_tbl+37*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 96]
push rax
mov rax, qword [fvar_tbl + 208]
push rax
mov rax, qword [fvar_tbl + 32]
push rax

            push 3  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode38)
 pop r8
         
 jmp Lcont41
 Lcode38:
 push rbp
             
 mov rbp, rsp
             
 
 ; generate lambda opt
          
 MALLOC rax, 16
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode40)
 pop r8
         
 jmp Lcont43
 Lcode40:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 1, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 1)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_98
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_98:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse6
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +32; insert const from const table to rax
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_100
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop28:
              cmp rcx, rsp            ;end of new stack
              jl Change28
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop28
Change28:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_100:
        ;                           finish generate applic tp
 jmp Lexit96
Lelse6:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_104
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_104:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_102
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop30:
              cmp rcx, rsp            ;end of new stack
              jl Change30
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop30
Change30:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_102:
        ;                           finish generate applic tp
Lexit96:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont43:
 leave
             
 ret
         
 Lcont41:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_105
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_105:
            ;                     finish generate applic
mov [fvar_tbl+12*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode41)
 pop r8
         
 jmp Lcont45
 Lcode41:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate ifmov rax, qword [rbp + 32]
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse7
mov rax, const_tbl +2; insert const from const table to rax
 jmp Lexit106
Lelse7:
mov rax, const_tbl +4; insert const from const table to rax
Lexit106:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont45:
         ;                    finish generate lambda simple
mov [fvar_tbl+38*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 32]
push rax
mov rax, qword [fvar_tbl + 216]
push rax
mov rax, qword [fvar_tbl + 208]
push rax
mov rax, qword [fvar_tbl + 176]
push rax
mov rax, qword [fvar_tbl + 168]
push rax
mov rax, qword [fvar_tbl + 160]
push rax
mov rax, qword [fvar_tbl + 152]
push rax
mov rax, qword [fvar_tbl + 144]
push rax
mov rax, qword [fvar_tbl + 256]
push rax
mov rax, qword [fvar_tbl + 264]
push rax
mov rax, qword [fvar_tbl + 128]
push rax
mov rax, qword [fvar_tbl + 16]
push rax
mov rax, qword [fvar_tbl + 8]
push rax

            push 13  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 105; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode43)
 pop r8
         
 jmp Lcont47
 Lcode43:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode45)
 pop r8
         
 jmp Lcont49
 Lcode45:
 push rbp
             
 mov rbp, rsp
             
 ;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode47)
 pop r8
         
 jmp Lcont51
 Lcode47:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_113
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_113:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse9
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_115
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_115:
            ;                     finish generate applic
 jmp Lexit111
Lelse9:
mov rax, const_tbl +2; insert const from const table to rax
Lexit111:
             ;                  finish generate if
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse8
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_119
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_119:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_117
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop34:
              cmp rcx, rsp            ;end of new stack
              jl Change34
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop34
Change34:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_117:
        ;                           finish generate applic tp
 jmp Lexit110
Lelse8:
;                  generate if;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_123
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_123:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse11
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_125
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_125:
            ;                     finish generate applic
 jmp Lexit121
Lelse11:
mov rax, const_tbl +2; insert const from const table to rax
Lexit121:
             ;                  finish generate if
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse10
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 40]
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_129
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_129:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_127
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop36:
              cmp rcx, rsp            ;end of new stack
              jl Change36
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop36
Change36:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_127:
        ;                           finish generate applic tp
 jmp Lexit120
Lelse10:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_131
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop38:
              cmp rcx, rsp            ;end of new stack
              jl Change38
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop38
Change38:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_131:
        ;                           finish generate applic tp
Lexit120:
             ;                  finish generate if
Lexit110:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont51:
         ;                    finish generate lambda simple
 leave
             
 ret
         
 Lcont49:
         ;                    finish generate lambda simple
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode49)
 pop r8
         
 jmp Lcont53
 Lcode49:
 push rbp
             
 mov rbp, rsp
             
 
 ; generate lambda opt
          
 MALLOC rax, 24
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode51)
 pop r8
         
 jmp Lcont55
 Lcode51:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 0, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 0)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 32]
push rax
mov rax, const_tbl +34; insert const from const table to rax
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_136
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_136:
            ;                     finish generate applic
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_134
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop40:
              cmp rcx, rsp            ;end of new stack
              jl Change40
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop40
Change40:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_134:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont55:
 mov qword [fvar_tbl + 144], rax
                                                  
 mov rax, SOB_VOID_ADDRESS

 ; generate lambda opt
          
 MALLOC rax, 24
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode52)
 pop r8
         
 jmp Lcont57
 Lcode52:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 0, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 0)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 32]
push rax
mov rax, const_tbl +51; insert const from const table to rax
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +48]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_141
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_141:
            ;                     finish generate applic
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_139
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop42:
              cmp rcx, rsp            ;end of new stack
              jl Change42
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop42
Change42:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_139:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont57:
 mov qword [fvar_tbl + 152], rax
                                                  
 mov rax, SOB_VOID_ADDRESS
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +56]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_144
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_144:
            ;                     finish generate applic
push rax

            push 1  ; number of args
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode53)
 pop r8
         
 jmp Lcont59
 Lcode53:
 push rbp
             
 mov rbp, rsp
             
 
 ; generate lambda opt
          
 MALLOC rax, 32
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 mov qword rdx, [rbx +16]
                                       
 mov qword [rax+ 24], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode55)
 pop r8
         
 jmp Lcont61
 Lcode55:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 1, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 1)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +16]
                                                              
 mov rax, qword[rax +96]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_148
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_148:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse12
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 32]
push rax
mov rax, const_tbl +51; insert const from const table to rax
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_150
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop44:
              cmp rcx, rsp            ;end of new stack
              jl Change44
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop44
Change44:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_150:
        ;                           finish generate applic tp
 jmp Lexit146
Lelse12:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +16]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_152
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop46:
              cmp rcx, rsp            ;end of new stack
              jl Change46
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop46
Change46:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_152:
        ;                           finish generate applic tp
Lexit146:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont61:
 leave
             
 ret
         
 Lcont59:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_153
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_153:
            ;                     finish generate applic
 mov qword [fvar_tbl + 160], rax
                                                  
 mov rax, SOB_VOID_ADDRESS
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode56)
 pop r8
         
 jmp Lcont63
 Lcode56:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 32 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 mov qword rdx, [rbx +16]
                                       
 mov qword [rax+ 24], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode58)
 pop r8
         
 jmp Lcont65
 Lcode58:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 40 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 mov qword rdx, [rbx +16]
                                       
 mov qword [rax+ 24], rdx
 mov qword rdx, [rbx +24]
                                       
 mov qword [rax+ 32], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode60)
 pop r8
         
 jmp Lcont67
 Lcode60:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +24]
                                                              
 mov rax, qword[rax +96]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_160
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_160:
            ;                     finish generate applic
cmp rax, SOB_FALSE_ADDRESS
                                                                
 jne Lexit159
;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +24]
                                                              
 mov rax, qword[rax +80]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_164
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_164:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_165
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_165:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse13
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +24]
                                                              
 mov rax, qword[rax +88]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_171
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_171:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +24]
                                                              
 mov rax, qword[rax +80]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_169
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_169:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_167
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop52:
              cmp rcx, rsp            ;end of new stack
              jl Change52
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop52
Change52:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_167:
        ;                           finish generate applic tp
 jmp Lexit161
Lelse13:
mov rax, const_tbl +2; insert const from const table to rax
Lexit161:
             ;                  finish generate if

Lexit159:
 leave
             
 ret
         
 Lcont67:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS

 ; generate lambda opt
          
 MALLOC rax, 40
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 mov qword rdx, [rbx +16]
                                       
 mov qword [rax+ 24], rdx
 mov qword rdx, [rbx +24]
                                       
 mov qword [rax+ 32], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode62)
 pop r8
         
 jmp Lcont69
 Lcode62:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 1, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 1)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_174
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop54:
              cmp rcx, rsp            ;end of new stack
              jl Change54
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop54
Change54:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_174:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont69:

 leave
             
 ret
         
 Lcont65:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_157
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop50:
              cmp rcx, rsp            ;end of new stack
              jl Change50
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop50
Change50:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_157:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont63:
         ;                    finish generate lambda simple
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode63)
 pop r8
         
 jmp Lcont71
 Lcode63:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +64]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_177
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_177:
            ;                     finish generate applic
push rax

            push 1  ; number of args
mov rax, qword [rbp + 32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_178
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_178:
            ;                     finish generate applic
 mov qword [fvar_tbl + 168], rax
                                                  
 mov rax, SOB_VOID_ADDRESS
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +72]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_181
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_181:
            ;                     finish generate applic
push rax

            push 1  ; number of args
mov rax, qword [rbp + 32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_182
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_182:
            ;                     finish generate applic
 mov qword [fvar_tbl + 176], rax
                                                  
 mov rax, SOB_VOID_ADDRESS

 leave
             
 ret
         
 Lcont71:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_155
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop48:
              cmp rcx, rsp            ;end of new stack
              jl Change48
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop48
Change48:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_155:
        ;                           finish generate applic tp

 leave
             
 ret
         
 Lcont53:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_109
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop32:
              cmp rcx, rsp            ;end of new stack
              jl Change32
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop32
Change32:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_109:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont47:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_183
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_183:
            ;                     finish generate applic
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 32]
push rax
mov rax, qword [fvar_tbl + 144]
push rax
mov rax, qword [fvar_tbl + 224]
push rax

            push 3  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode65)
 pop r8
         
 jmp Lcont73
 Lcode65:
 push rbp
             
 mov rbp, rsp
             
 
 ; generate lambda opt
          
 MALLOC rax, 16
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode67)
 pop r8
         
 jmp Lcont75
 Lcode67:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 1, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 1)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_188
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_188:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse14
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax
mov rax, const_tbl +68; insert const from const table to rax
push rax

            push 2  ; number of args
mov rax, qword [fvar_tbl + 152]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_192
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_192:
            ;                     finish generate applic
push rax
mov rax, const_tbl +34; insert const from const table to rax
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_190
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop56:
              cmp rcx, rsp            ;end of new stack
              jl Change56
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop56
Change56:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_190:
        ;                           finish generate applic tp
 jmp Lexit186
Lelse14:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_197
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_197:
            ;                     finish generate applic
push rax
mov rax, const_tbl +68; insert const from const table to rax
push rax

            push 2  ; number of args
mov rax, qword [fvar_tbl + 152]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_198
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_198:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_194
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop58:
              cmp rcx, rsp            ;end of new stack
              jl Change58
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop58
Change58:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_194:
        ;                           finish generate applic tp
Lexit186:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont75:
 leave
             
 ret
         
 Lcont73:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_199
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_199:
            ;                     finish generate applic
mov [fvar_tbl+39*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 168]
push rax
mov rax, qword [fvar_tbl + 176]
push rax
mov rax, qword [fvar_tbl + 216]
push rax
mov rax, qword [fvar_tbl + 208]
push rax
mov rax, qword [fvar_tbl + 304]
push rax
mov rax, qword [fvar_tbl + 32]
push rax

            push 6  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 49; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode68)
 pop r8
         
 jmp Lcont77
 Lcode68:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode70)
 pop r8
         
 jmp Lcont79
 Lcode70:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode72)
 pop r8
         
 jmp Lcont81
 Lcode72:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_205
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_205:
            ;                     finish generate applic
cmp rax, SOB_FALSE_ADDRESS
                                                                
 jne Lexit204
;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_210
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_210:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_211
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_211:
            ;                     finish generate applic
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_212
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_212:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse15
;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_217
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_217:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +40]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_218
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_218:
            ;                     finish generate applic
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_219
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_219:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse16
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_225
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_225:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_223
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_223:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_221
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop62:
              cmp rcx, rsp            ;end of new stack
              jl Change62
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop62
Change62:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_221:
        ;                           finish generate applic tp
 jmp Lexit213
Lelse16:
mov rax, const_tbl +2; insert const from const table to rax
Lexit213:
             ;                  finish generate if
 jmp Lexit206
Lelse15:
mov rax, const_tbl +2; insert const from const table to rax
Lexit206:
             ;                  finish generate if

Lexit204:
 leave
             
 ret
         
 Lcont81:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS

 ; generate lambda opt
          
 MALLOC rax, 24
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode74)
 pop r8
         
 jmp Lcont83
 Lcode74:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 1, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 1)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_228
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop64:
              cmp rcx, rsp            ;end of new stack
              jl Change64
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop64
Change64:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_228:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont83:

 leave
             
 ret
         
 Lcont79:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_202
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop60:
              cmp rcx, rsp            ;end of new stack
              jl Change60
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop60
Change60:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_202:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont77:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_229
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_229:
            ;                     finish generate applic
mov [fvar_tbl+40*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 216]
push rax
mov rax, qword [fvar_tbl + 208]
push rax
mov rax, qword [fvar_tbl + 32]
push rax
mov rax, qword [fvar_tbl + 200]
push rax

            push 4  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 33; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode75)
 pop r8
         
 jmp Lcont85
 Lcode75:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode77)
 pop r8
         
 jmp Lcont87
 Lcode77:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode79)
 pop r8
         
 jmp Lcont89
 Lcode79:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_235
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_235:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse17
mov rax, qword [rbp + 32]
 jmp Lexit233
Lelse17:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_243
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_243:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_240
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_240:
            ;                     finish generate applic
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_241
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_241:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_237
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop68:
              cmp rcx, rsp            ;end of new stack
              jl Change68
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop68
Change68:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_237:
        ;                           finish generate applic tp
Lexit233:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont89:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS

 ; generate lambda opt
          
 MALLOC rax, 24
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode81)
 pop r8
         
 jmp Lcont91
 Lcode81:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 0, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 0)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_247
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_247:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse18
mov rax, const_tbl +34; insert const from const table to rax
 jmp Lexit245
Lelse18:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_253
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_253:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_251
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_251:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_249
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop70:
              cmp rcx, rsp            ;end of new stack
              jl Change70
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop70
Change70:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_249:
        ;                           finish generate applic tp
Lexit245:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont91:

 leave
             
 ret
         
 Lcont87:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_232
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop66:
              cmp rcx, rsp            ;end of new stack
              jl Change66
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop66
Change66:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_232:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont85:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_254
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_254:
            ;                     finish generate applic
mov [fvar_tbl+25*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 168]
push rax

            push 1  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode82)
 pop r8
         
 jmp Lcont93
 Lcode82:
 push rbp
             
 mov rbp, rsp
             
 ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode84)
 pop r8
         
 jmp Lcont95
 Lcode84:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +34; insert const from const table to rax
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_257
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop72:
              cmp rcx, rsp            ;end of new stack
              jl Change72
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop72
Change72:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_257:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont95:
         ;                    finish generate lambda simple
 leave
             
 ret
         
 Lcont93:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_258
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_258:
            ;                     finish generate applic
mov [fvar_tbl+41*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 192]
push rax
mov rax, qword [fvar_tbl + 168]
push rax
mov rax, qword [fvar_tbl + 16]
push rax

            push 3  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode86)
 pop r8
         
 jmp Lcont97
 Lcode86:
 push rbp
             
 mov rbp, rsp
             
 ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode88)
 pop r8
         
 jmp Lcont99
 Lcode88:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_262
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_262:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse19
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +51; insert const from const table to rax
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_266
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_266:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_264
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop74:
              cmp rcx, rsp            ;end of new stack
              jl Change74
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop74
Change74:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_264:
        ;                           finish generate applic tp
 jmp Lexit260
Lelse19:
mov rax, const_tbl +2; insert const from const table to rax
Lexit260:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont99:
         ;                    finish generate lambda simple
 leave
             
 ret
         
 Lcont97:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_267
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_267:
            ;                     finish generate applic
mov [fvar_tbl+42*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 16]
push rax
mov rax, qword [fvar_tbl + 8]
push rax

            push 2  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode90)
 pop r8
         
 jmp Lcont101
 Lcode90:
 push rbp
             
 mov rbp, rsp
             
 ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode92)
 pop r8
         
 jmp Lcont103
 Lcode92:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_271
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_271:
            ;                     finish generate applic
cmp rax, SOB_FALSE_ADDRESS
                                                                
 jne Lexit270
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 32]
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_273
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop76:
              cmp rcx, rsp            ;end of new stack
              jl Change76
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop76
Change76:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_273:
        ;                           finish generate applic tp

Lexit270:
 leave
             
 ret
         
 Lcont103:
         ;                    finish generate lambda simple
 leave
             
 ret
         
 Lcont101:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_274
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_274:
            ;                     finish generate applic
mov [fvar_tbl+43*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 144]
push rax
mov rax, qword [fvar_tbl + 264]
push rax

            push 2  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode94)
 pop r8
         
 jmp Lcont105
 Lcode94:
 push rbp
             
 mov rbp, rsp
             
 ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode96)
 pop r8
         
 jmp Lcont107
 Lcode96:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 32]
push rax
mov rax, const_tbl +34; insert const from const table to rax
push rax
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode98)
 pop r8
         
 jmp Lcont109
 Lcode98:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +51; insert const from const table to rax
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_279
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop80:
              cmp rcx, rsp            ;end of new stack
              jl Change80
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop80
Change80:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_279:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont109:
         ;                    finish generate lambda simple
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_277
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop78:
              cmp rcx, rsp            ;end of new stack
              jl Change78
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop78
Change78:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_277:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont107:
         ;                    finish generate lambda simple
 leave
             
 ret
         
 Lcont105:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_280
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_280:
            ;                     finish generate applic
mov [fvar_tbl+44*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 232]
push rax
mov rax, qword [fvar_tbl + 312]
push rax
mov rax, qword [fvar_tbl + 176]
push rax
mov rax, qword [fvar_tbl + 72]
push rax
mov rax, qword [fvar_tbl + 80]
push rax

            push 5  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 41; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode100)
 pop r8
         
 jmp Lcont111
 Lcode100:
 push rbp
             
 mov rbp, rsp
             
 ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode102)
 pop r8
         
 jmp Lcont113
 Lcode102:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode104)
 pop r8
         
 jmp Lcont115
 Lcode104:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 32 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 mov qword rdx, [rbx +16]
                                       
 mov qword [rax+ 24], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode106)
 pop r8
         
 jmp Lcont117
 Lcode106:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, const_tbl +34; insert const from const table to rax
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +16]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_286
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_286:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse20
mov rax, qword [rbp + 40]
 jmp Lexit284
Lelse20:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +16]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_293
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_293:
            ;                     finish generate applic
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +16]
                                                              
 mov rax, qword[rax +32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_294
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_294:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, const_tbl +51; insert const from const table to rax
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +16]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_290
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_290:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_288
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop84:
              cmp rcx, rsp            ;end of new stack
              jl Change84
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop84
Change84:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_288:
        ;                           finish generate applic tp
Lexit284:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont117:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +1; insert const from const table to rax
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, const_tbl +51; insert const from const table to rax
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_299
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_299:
            ;                     finish generate applic
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_300
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_300:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 32]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_296
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop86:
              cmp rcx, rsp            ;end of new stack
              jl Change86
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop86
Change86:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_296:
        ;                           finish generate applic tp

 leave
             
 ret
         
 Lcont115:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_283
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop82:
              cmp rcx, rsp            ;end of new stack
              jl Change82
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop82
Change82:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_283:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont113:
         ;                    finish generate lambda simple
 leave
             
 ret
         
 Lcont111:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_301
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_301:
            ;                     finish generate applic
mov [fvar_tbl+45*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 112]
push rax
mov rax, qword [fvar_tbl + 216]
push rax
mov rax, qword [fvar_tbl + 208]
push rax
mov rax, qword [fvar_tbl + 136]
push rax
mov rax, qword [fvar_tbl + 48]
push rax
mov rax, qword [fvar_tbl + 40]
push rax
mov rax, qword [fvar_tbl + 24]
push rax
mov rax, qword [fvar_tbl + 8]
push rax
mov rax, qword [fvar_tbl + 16]
push rax
mov rax, qword [fvar_tbl + 360]
push rax
mov rax, qword [fvar_tbl + 168]
push rax

            push 11  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 89; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode108)
 pop r8
         
 jmp Lcont119
 Lcode108:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode110)
 pop r8
         
 jmp Lcont121
 Lcode110:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode112)
 pop r8
         
 jmp Lcont123
 Lcode112:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_308
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_308:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse22
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_310
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_310:
            ;                     finish generate applic
 jmp Lexit306
Lelse22:
mov rax, const_tbl +2; insert const from const table to rax
Lexit306:
             ;                  finish generate if
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse21
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_312
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop90:
              cmp rcx, rsp            ;end of new stack
              jl Change90
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop90
Change90:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_312:
        ;                           finish generate applic tp
 jmp Lexit305
Lelse21:
;                  generate if;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_316
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_316:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse24
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +24]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_318
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_318:
            ;                     finish generate applic
 jmp Lexit314
Lelse24:
mov rax, const_tbl +2; insert const from const table to rax
Lexit314:
             ;                  finish generate if
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse23
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_320
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop92:
              cmp rcx, rsp            ;end of new stack
              jl Change92
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop92
Change92:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_320:
        ;                           finish generate applic tp
 jmp Lexit313
Lelse23:
;                  generate if;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +40]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_324
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_324:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse26
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +40]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_326
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_326:
            ;                     finish generate applic
 jmp Lexit322
Lelse26:
mov rax, const_tbl +2; insert const from const table to rax
Lexit322:
             ;                  finish generate if
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse25
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +80]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_332
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_332:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +80]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_330
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_330:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_328
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop94:
              cmp rcx, rsp            ;end of new stack
              jl Change94
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop94
Change94:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_328:
        ;                           finish generate applic tp
 jmp Lexit321
Lelse25:
;                  generate if;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_336
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_336:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse28
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_338
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_338:
            ;                     finish generate applic
 jmp Lexit334
Lelse28:
mov rax, const_tbl +2; insert const from const table to rax
Lexit334:
             ;                  finish generate if
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse27
;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +64]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_344
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_344:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +64]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_342
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_342:
            ;                     finish generate applic
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_345
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_345:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse29
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +72]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_351
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_351:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +72]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_349
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_349:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_347
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop96:
              cmp rcx, rsp            ;end of new stack
              jl Change96
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop96
Change96:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_347:
        ;                           finish generate applic tp
 jmp Lexit339
Lelse29:
mov rax, const_tbl +2; insert const from const table to rax
Lexit339:
             ;                  finish generate if
 jmp Lexit333
Lelse27:
;                  generate if;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +48]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_355
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_355:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse31
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +48]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_357
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_357:
            ;                     finish generate applic
 jmp Lexit353
Lelse31:
mov rax, const_tbl +2; insert const from const table to rax
Lexit353:
             ;                  finish generate if
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse30
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_363
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_363:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_361
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_361:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_359
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop98:
              cmp rcx, rsp            ;end of new stack
              jl Change98
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop98
Change98:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_359:
        ;                           finish generate applic tp
 jmp Lexit352
Lelse30:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +56]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_365
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop100:
              cmp rcx, rsp            ;end of new stack
              jl Change100
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop100
Change100:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_365:
        ;                           finish generate applic tp
Lexit352:
             ;                  finish generate if
Lexit333:
             ;                  finish generate if
Lexit321:
             ;                  finish generate if
Lexit313:
             ;                  finish generate if
Lexit305:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont123:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 32]
        
 mov rax, qword [rax]
        

 leave
             
 ret
         
 Lcont121:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_304
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop88:
              cmp rcx, rsp            ;end of new stack
              jl Change88
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop88
Change88:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_304:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont119:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_366
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_366:
            ;                     finish generate applic
mov [fvar_tbl+46*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                      generate define
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [fvar_tbl + 136]
push rax
mov rax, qword [fvar_tbl + 232]
push rax
mov rax, qword [fvar_tbl + 296]
push rax
mov rax, qword [fvar_tbl + 32]
push rax
mov rax, qword [fvar_tbl + 216]
push rax
mov rax, qword [fvar_tbl + 208]
push rax

            push 6  ; number of args
;                   generate lambda simple
         MALLOC rax, 8 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 push rax ; save pointer to _ env
          
; MALLOC rax, 49; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode114)
 pop r8
         
 jmp Lcont125
 Lcode114:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, const_tbl +23; insert const from const table to rax
push rax
mov rax, const_tbl +23; insert const from const table to rax
push rax
mov rax, const_tbl +23; insert const from const table to rax
push rax

            push 3;    push number of rands to stack
             ;                  gen rator
            ;                   generate lambda simple
         MALLOC rax, 16 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 25; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode116)
 pop r8
         
 jmp Lcont127
 Lcode116:
 push rbp
             
 mov rbp, rsp
             
 mov rax, qword [rbp + 32]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 32], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 40]
 MALLOC rbx, 8
        
 mov qword[rbx], rax
        
 mov rax, rbx
        
 mov qword [rbp + 40], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 9; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode118)
 pop r8
         
 jmp Lcont129
 Lcode118:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_373
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_373:
            ;                     finish generate applic
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_374
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_374:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse32
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
mov rax, qword [rbp + 32]
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_376
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop104:
              cmp rcx, rsp            ;end of new stack
              jl Change104
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop104
Change104:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_376:
        ;                           finish generate applic tp
 jmp Lexit370
Lelse32:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_380
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_380:
            ;                     finish generate applic
push rax

            push 1;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_378
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop106:
              cmp rcx, rsp            ;end of new stack
              jl Change106
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop106
Change106:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_378:
        ;                           finish generate applic tp
Lexit370:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont129:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 32]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS
;                   generate lambda simple
         MALLOC rax, 24 ; rax is pointer to _ env

         push rbx
         push rdx
         mov qword rbx, [rbp + 8*2] ; get curr env
 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax ; save pointer to _ env
          
; MALLOC rax, 17; num of params
         mov rcx, [rbp + 8*3]     ;;father function argc
         lea rax, [8*rcx]
         MALLOC rax, rax    ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx ; insert pointer to param's arr to _ env[0]
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
 MAKE_CLOSURE(rax ,r8, Lcode120)
 pop r8
         
 jmp Lcont131
 Lcode120:
 push rbp
             
 mov rbp, rsp
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_384
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_384:
            ;                     finish generate applic
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +40]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_385
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_385:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse33
mov rax, qword [rbp + 40]
 jmp Lexit381
Lelse33:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +8]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_392
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_392:
            ;                     finish generate applic
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
        
 mov rax, qword [rax]
        
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_393
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_393:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 32]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +0]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_389
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_389:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +32]
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_387
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop108:
              cmp rcx, rsp            ;end of new stack
              jl Change108
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop108
Change108:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_387:
        ;                           finish generate applic tp
Lexit381:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont131:
         ;                    finish generate lambda simple
 push rax
mov rax, qword [rbp + 40]
 pop qword [rax]    
         
 mov rax, SOB_VOID_ADDRESS

 ; generate lambda opt
          
 MALLOC rax, 24
 push rbx
         
 push rdx
         
 mov qword rbx, [rbp + 8*2]

 mov qword rdx, [rbx +0]
                                       
 mov qword [rax+ 8], rdx
 mov qword rdx, [rbx +8]
                                       
 mov qword [rax+ 16], rdx
 push rax
         mov rcx, [rbp + 8*3 ]            ;;father function argc
         ;inc rcx                          ;;magic
         lea rax, [8*rcx]
         MALLOC rax, rax                  ;;pointer to new params array
         cmp rcx, 0
         je .end_loop
         mov r9, 0
         .loop:
            mov r10, [rbp + 8*(4+r9)]
            mov [rax + 8*r9], r10
            inc r9
            loop .loop
          .end_loop:
         
 mov rdx, rax
         
 pop rax
         
 mov qword [rax], rdx
         
 pop rdx 
         
 pop rbx
         
 push r8
         
 mov r8, rax
         
 MAKE_CLOSURE (rax , r8, Lcode122)
 pop r8
         
 jmp Lcont133
 Lcode122:
             
 push rbp
             
 mov rbp, rsp
             
 push rdx
             
 push rcx
             
 push rbx
             
 push rax
 OPT_PARAMS 1, SOB_NIL_ADDRESS
 mov qword [rbp+8*(4 + 1)], rdx
             
 pop rax
             
 pop rbx
             
 pop rcx
             
 pop rdx
             
 ;                  generate if;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +16]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_397
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_397:
            ;                     finish generate applic
 cmp rax, SOB_FALSE_ADDRESS
             
 je Lelse34
mov rax, qword [rbp + 32]
 jmp Lexit395
Lelse34:
;                  generate applic tp
push SOB_NIL_ADDRESS ; magic 
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax

            push 1  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +0]
        
 mov rax, qword [rax]
        
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_403
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_403:
            ;                     finish generate applic
push rax
;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, qword [rbp + 40]
push rax
mov rax, qword [rbp + 32]
push rax

            push 2  ; number of args
mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +8]
                                                              
 mov rax, qword[rax +32]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_401
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_401:
            ;                     finish generate applic
push rax

            push 2;    push number of rands to stack
             ;                  gen rator
            mov rax, qword [rbp + 8*2]
                                                              
 mov rax, qword[rax +0]
                                                              
 mov rax, qword[rax +8]
        
 mov rax, qword [rax]
        
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_399
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop110:
              cmp rcx, rsp            ;end of new stack
              jl Change110
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop110
Change110:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_399:
        ;                           finish generate applic tp
Lexit395:
             ;                  finish generate if
 leave
             
 ret
         
 Lcont133:
 mov qword [rbp + 48], rax
                                                              
 mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 48]

 leave
             
 ret
         
 Lcont127:
         ;                    finish generate lambda simple
            mov rsi, rax
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE         ; check if rax is clouser
            jne Exit_applic_369
            CLOSURE_ENV rsi, rax      ; get env from closure
            push rsi                  ; push env
            push qword [rbp + 8 * 1]  ; old ret addr

            ;                       fixing the stack
            push qword[rbp]
            mov rsi, rax              ; mov closure pointer to rsi
            mov rax, rbp              ; save rbp in rax
            mov r8, [rbp+3*8]         ; arg count
            ;;sub r8, 1                 ; we want to get arg i in place i-1
            add r8, 4 
            shl r8, 3
            add rax, r8      
            mov rcx, rbp              ; rcx address first obj of this stack
            sub rcx, 8 
Loop102:
              cmp rcx, rsp            ;end of new stack
              jl Change102
              mov rbx, [rcx]
              mov [rax], rbx
              sub rcx, 8
              sub rax, 8
              jmp Loop102
Change102:
              mov rsp, rax
              add rsp, 8
              pop rbp
            ;                       finish fixing the stack

        CLOSURE_CODE rsi, rsi
        jmp rsi                    ; push env, call code 
Exit_applic_369:
        ;                           finish generate applic tp
 leave
             
 ret
         
 Lcont125:
         ;                    finish generate lambda simple
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_404
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_404:
            ;                     finish generate applic
mov [fvar_tbl+47*WORD_SIZE], rax ; insert var to free var table
mov rax, SOB_VOID_ADDRESS ; define return void
          ;                       finish generate def
	call write_sob_if_not_void

;                  generate applic
push SOB_NIL_ADDRESS ; magic
mov rax, const_tbl +102; insert const from const table to rax
push rax
mov rax, const_tbl +85; insert const from const table to rax
push rax

            push 2  ; number of args
mov rax, qword [fvar_tbl + 144]
            mov rsi, rax  ; move the rator to rsi
            mov bl, byte [rsi]
            cmp bl, T_CLOSURE
            jne Exit_applic_406
            CLOSURE_ENV rsi, rax
            push rsi ;push env
            CLOSURE_CODE rsi, rax
            call rsi ;call code
            add rsp, 8*1 ;pop Env
            pop rbx ;pop arg count   
            add rbx, 1 ; including magic    
            shl rbx, 3 ;rbx=rbx*8
            add rsp,rbx ;pop args
Exit_applic_406:
            ;                     finish generate applic
	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR (rax, rsi, rdi)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CAR rax, rsi
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CDR rax, rsi
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi + 1], rdi
	 mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi + 9], rdi
   mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

apply:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	
        mov rax, [rbp+8*3]    ; apply argcount
        cmp rax, 2
        ;;jb ERROR
        je .no_variadic

        lea rdi, [rbp+8*(rax+3)]  ; last arg to rdi
        mov rcx, rax
        sub rcx, 2    ; def loop num

        .make_list:
          mov r8, [rdi-8] ;car to r8
          mov r9, [rdi]   ;cdr to r9
          MAKE_PAIR(rbx, r8, r9)
          sub rdi, 8
          mov [rdi], rbx
          loop .make_list

          mov rdi, [rdi]

        .no_variadic:
        mov rcx, 0    ; counter for params
        mov rbx, rdi  ; list to rbx
        mov rax, 0    ; 0 to cmp type
        push SOB_NIL_ADDRESS  ;push magic
        .loop:
          mov al, byte [rbx]
          cmp al, T_NIL     ; check end of list
          je .end_loop
          inc rcx
          push qword [rbx+1]    ; push car of rbx
          mov rbx, [rbx+9]      ; cdr of rbx to rbx
          jmp .loop           

        .end_loop:
          mov r8, rsp             ; first param pointer to r8
          lea r9, [rsp+8*(rcx-1)] ; last param pointer to r9
          .reverse_loop:
            cmp r9, r8
            jle .fin_reverse_loop
            mov r10, [r8] ; tmp1 =[r8]
            mov r11, [r9] ; tmp2 = [r9]
            mov [r9], r10 ; [r9] = tmp1 = [r8]
            mov [r8], r11 ; [r8] = tmp2 = [r9]
            sub r9, 8
            add r8, 8
            jmp .reverse_loop

        .fin_reverse_loop:
          push rcx                  ;; push param count
          cmp byte [rsi], T_CLOSURE
          ;;jne ERROR
          push qword [rsi+1]        ;; push env
          push qword [rbp+8*1]      ;; push father function ret address

          mov r8, [rbp]             ;; save old rbp
          add rcx, 4                ;; number of loops needed--3
          mov rbx, [rbp+ 8*3]       ;; father function arg count 
          lea rdx, [rbp+8*(rbx+4)]  ;; last father function argument --3
          mov r9, [rsp+2*8]         ;; new arg count
          lea r9, [rsp + 8*(3+r9)]  ;; new function last arg --2

          .loop_applyTP:
            mov rax, [r9]
            mov qword [rdx], rax
            sub r9, 8
            sub rdx, 8
            loop .loop_applyTP
            mov rbp, r8
            lea rsp, [rdx+8]
            jmp qword [rsi+9]  ; closure code is at SOB_CLOSURE + 9
            
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret